The general concept of addition (standard or parallel) in any numeration system $(\beta,\A)$, such that $\fin{\A}$ is closed under addition, is following: we add numbers digitwise and then we convert the result into the alphabet $\A$. Obviously, digitwise addition is computable in parallel, thus the crucial point is the conversion of the obtained result. It can be easily done in a standard way but a parallel digit set conversion is nontrivial. However, formulas are basically same but the choice of coefficients differs.

Now we go step by step more precisely. Let $x=\sum_{-m'}^{n'} x_i\beta^i,y=\sum_{-m'}^{n'} y_i\beta^i \in \fin{\A}$ with $(\beta,\A)$-representantions padded by zeros to have the same length. We set 
  \begin{align*}
    w&=x+y =\sum_{-m'}^{n'} x_i\beta^i + \sum_{-m'}^{n'} y_i\beta^i = \sum_{-m'}^{n'} (x_i+y_i)\beta^i \\
    &=\sum_{-m'}^{n'} w_i\beta^i \,,
  \end{align*}
  where $w_j=x_j+y_j \in \A +\A$. Thus, $w_{n'} w_{{n'}-1}\cdots w_1 w_0 \bullet w_{-1} w_{-2} \cdots w_{-m'}$ is a  $(\beta, \A+\A)$-representation of $w\in \fin{\A+\A}$. 

We also use column notation of addition in the following, e.g.,     
  \begin{align*}
  x_{n'} \;x_{{n'}-1}\cdots x_1 \;x_0 &\bullet x_{-1} \;x_{-2}\, \cdots x_{-m'} \\[-3pt]
  y_{n'} \;y_{{n'}-1}\cdots y_1 \,\;y_0 &\bullet y_{-1} \;y_{-2} \;\cdots y_{-m'} \\[-7pt]
    \line(1,0){90} & \line(1,0){100} \\[-7pt]
  w_{n'} w_{{n'}-1}\cdots w_1 w_0 &\bullet w_{-1} w_{-2} \cdots w_{-m'}\,.
  \end{align*}
  
As we want to obtain a $(\beta,\A)$-representation of $w$, we search a sequence 
  $$z_{n} z_{n-1}\cdots z_1 z_0 z_{-1} z_{-2} \cdots z_{-m}$$ such that $z_j \in \A$ and
  $$
    z_{n} z_{n-1}\cdots z_1 z_0 \bullet z_{-1} z_{-2} \cdots z_{-m}=(w)_{\beta,\A}\,.
  $$
  In the next, we consider without lost of generality only $\beta$-integers since modification for representations with rational part is obvious:
  $$
  \beta^m \cdot z_{n} z_{n-1}\cdots z_1 z_0 \bullet z_{-1} z_{-2} \cdots z_{-m} = z_{n} z_{n-1}\cdots z_1 z_0 z_{-1} z_{-2} \cdots z_{-m} \bullet
  $$  
  Particulary, let $(w)_{\beta, \A+\A}=w_{n'} w_{{n'}-1}\cdots w_1 w_0 \bullet$. We search $n \in \NN$ and $z_{n}, z_{n-1},\dots, z_1, z_0 \in \A$ such that $(w)_{\beta, \A}=z_{n} z_{n-1}\cdots z_1 z_0 \bullet$.   
  
  We use suitable representation of zero to convert digits $w_j$ into the alphabet $\A$. 
  \begin{defn}
  For a base $\beta \in \Zomega$, a polynomial $R(x)=r_s x^s+r_{s-1}x^{s-1}+ \dots + r_1 x+r_0$ with coefficients $r_i \in \Zomega,$ such that $R(\beta)=0$, is called a \emph{rewriting rule}. MA TAM BYT Z[OMEGA] NEBO Z[BETA]???
  \end{defn}  
  
  An arbitrary rewriting rule may be used for conversion, then so called \emph{core coefficient}, i.e., one of the coefficients which is greatest in modulus, is applied to convert a digit $w_j$. For our purpose, we use the simplest possible rewriting rule
  $$
    R(x)=x-\beta \in \Zomega[x]\,.
  $$
As $0=\beta^{j} \cdot R(\beta)=1\cdot \beta^{j+1} -\beta \cdot \beta^{j}$, we have a representation of zero 
$$1 (-\!\beta) \underbrace{0 \cdots 0}_{j}\bullet = (0)_\beta\,. $$
for all $j \in \NN$. We multiply this representation by $q_j \in \Zomega$ which is called a \emph{weight coefficient} to obtain representation of zero 
$$q_j (-q_j\beta) \underbrace{0 \cdots 0}_{j}\bullet = (0)_\beta\,. $$ 
This is digitwise added to $w_{n} w_{n-1}\cdots w_1 w_0 \bullet$ to convert the digit $w_j$ into the alphabet $\A$. It causes a \emph{carry} $q_{j}$ on the $(j+1)$-th position from the conversion of $j$-th digit. The conversion runs from right ($j=0$) to left until all digits and carries are converted into the alphabet $\A$:
        \begin{align*}
            \hspace{100pt}  w_n w_{n-1}&&&\cdots& &w_{j+1}&\!\! &\textcolor{red}{w_j}  & \!\!  &w_{j-1} &&\cdots &&w_1 w_0\bullet \hspace{100pt} \\[-5pt]
                         &&&&       &       & &     &   &q_{j-2} &&\iddots\\[-3pt] 
                         &&&&       &       & &\textcolor{red}{q_{j-1}}& -&\beta q_{j-1} \\[-3pt]
                         &&&&         &q_j&   \textcolor{red}{-}&\textcolor{red}{\beta q_j} &&\\[-8pt]
                         &&&  \iddots      &   -&\beta q_{j+1}&   &\ &&\\[-17pt]
          \intertext{\hspace{60pt}\line(1,0){300}}
          \vspace{-15pt}
          \\[-30pt]
           z_{n+s} \cdots z_{n} z_{n-1}&&&\cdots& &z_{j+1}& &\textcolor{red}{z_j}& &z_{j-1} &&\cdots &&z_1 \; z_0\bullet                  
        \end{align*}
    Hence, the desired formula for conversion on the $j$-th position is 
    \begin{equation*}
        z_j=w_j + q_{j-1} - q_j \beta
    \end{equation*}
    for $j \in \NN_0$. We set $q_{-1}=0$ as there is no carry from the right on the 0-th position.
    
     Clearly, the value of $w$ is preserved:
\begin{align*}
    \sum_{j\geq 0} z_j \beta^j &=w_0 - \beta q_0 + \sum_{j> 0} (w_j + q_{j-1} - q_j \beta) \beta^j \\
    &=\sum_{j\geq 0} w_j \beta^j + \sum_{j>0} q_{j-1} \beta^j - \sum_{j\geq 0} q_j \cdot \beta^{j+1} \\
    &=\sum_{j\geq 0} w_j \beta^j + \sum_{j>0} q_{j-1} \beta^j - \sum_{j> 0} q_{j-1} \cdot \beta^j \\
    &=\sum_{j\geq 0} w_j \beta^j = w\,.
\end{align*}

     The weight coefficient $q_j$ must be chosen such that the converted digit is in the alphabet~$\A$, i.e., 
    \begin{equation}
    \label{eq:conversionFormula}
        z_j=w_j + q_{j-1} - q_j \beta \in \A\,.
    \end{equation}
    Choice of weight coefficients is the crucial part in the case of construction of parallel addition algorithms. The method determining weight coefficients for a given input is decribed in Section~\ref{sec:methodDescription}.
    
     On the other hand, it is trivial for standard numeration systems.  Notice that
    $$
        z_j \equiv w_j+q_{j-1} \mod \beta\,. 
    $$
  Assume now a standard numeration system $(\beta, \A)$, where
  $$
    \beta \in \NN\,,\beta  \geq 2\,, \A = \{0, 1, 2,\dots, \beta -1 \}\,.
  $$ 
  There is only one representative of each class modulo  $\beta$. Therefore, the digit $z_j$ is uniquely determined for a given digit $w_j \in \A+\A$ and carry $q_{j-1}$ and thus so is the weight coefficient $q_j$. This means that $q_j=q_j(w_j,q_{j-1})$ for all $j\geq 0$. Generally,
  $$
  q_j=q_j(w_j,q_{j-1}(w_{j-1},q_{j-2}))=\dots =q_j(w_j ,\dots , w_1, w_0)
  $$
  and
  $$
  z_j=z_j(w_j ,\dots , w_1, w_0)\,,
  $$
  which implies that addition runs in linear time.
  
  We want to the digit set conversion from $\A+\A$ into $\A$ be computable in parallel, i.e., there exist constants $r,t \in \NN_0$ such that for all $j\geq 0$ is $z_j=z_j(w_{j+r},\dots,w_{j-t})$. To avoid the dependency on all less, respectivelly more, significant digits, we need variety in the choice of weight coefficient $q_j$. This implies that the used numeration system must be redundant.
  
  
  
  NEJAKE LEMMA O TOM, ZE NEREDUNDANTNI SYSTEM VEDE NA LINEARNI CAS???


\section{Method}
\label{sec:methodDescription}
In order to construct a parallel digit set conversion in numeration system $(\beta,\A)$ we consider more general case of conversion from an \emph{input alphabet} $\B$ such that $\A \subsetneq \B \subset \A +\A$ instead of the alphabet $\A+\A$.
As menshioned above, the key problem is to find for every $j\geq 0$ a weight coefficient $q_j$ such that 
    $$
        z_j=\underbrace{w_j}_{\in \B} + q_{j-1} - q_j \beta \in \A 
    $$  
    for any input $w\in \fin{\B}, (w)_{\beta,\B}=w_{n'}w_{n'-1}\dots w_1 w_0 \bullet$. We remark that the weight coefficient $q_{j-1}$ is determined by the input $w$. For digit set conversion to be computable in parallel we demand to digit $z_j=z_j(w_{j+r},\dots,w_{j-t})$ for a fixed anticipation $r$ and memory $t$ in $\NN_0$.
    
    We introduce following definitions to obtain the desired digit set conversion. 
    \begin{defn}
        Let $\B$ be a set such that $\A \subsetneq \B \subset \A +\A$. Then any finite set $\Q\subset\Zomega$ containing~0 such that 
        $$
            \B + \Q \subset \A + \beta \Q
        $$  
        is called a \emph{set of weight coefficients}.
    \end{defn}
    We see that
        $$
        (\forall w_j \in \B)(\forall q_{j-1}\in\Q)(\exists q_j \in \Q )(w_j + q_{j-1} - q_j \beta \in \A )\,.
        $$
    Accordingly, there is a weight coefficient $q_j \in \Q$ for any carry from the right $q_{j-1}\in \Q$ and any digit $w_j$ in the input alphabet $\B$. I.e., we  satisfy basic conversion formula (\ref{eq:conversionFormula}). Notice that $q_{-1}=0$ is in $\Q$ by definition. Thus, all weight coeficients may be chosen from $\Q$ inductively.
    \begin{defn}
    Let $M$ be an integer and $q:\B^{M} \rightarrow \Q$ be a mapping such that 
    $$
    w_j+ q(w_{j-1}, \dots, w_{j-M}) - \beta q(w_j, \dots, w_{j-M+1}) \in \A
    $$
    for all $w_j,w_{j-1}, \dots, w_{j-M} \in \B$. Then $q$ is called a \emph{weight function} and $M$ is called a \emph{length of window}.    
    \end{defn}
 
 JE TREBA POZADOVAT q(0,...,0)=0 NEBO TO Z NECEHO PLYNE?

 Having a weight function $q$, we define a function $\phi:\B^{M+1}\rightarrow \A$ by
    $$
        \phi(w_{j}, \dots, w_{j-M})=w_j+ \underbrace{q(w_{j-1}, \dots, w_{j-M})}_{=q_{j-1}} - \beta \underbrace{q(w_j, \dots, w_{j-M+1})}_{=q_j}=:z_j\,,
    $$ 
    which verifies that the conversion is indeed $(M+1)$-local function with anticipation $r=0$ and memory $t=M$.
    
The construction of a parallel conversion algorithm by so-called \emph{extending window method} consists of two phases. In the first one, we find a minimal possible weight coefficient set $\Q$. It serves as the starting point for the second phase in which e increment the expected length of the window $M$ until the weight function $q$ is uniquely defined for each $(w_j,w_{j-1}, \dots , w_{j-M+1}) \in \B^{M}$.

\subsection{Phase 1 -- Weight coefficient set}
The goal of the first phase is to compute a weight coefficient set $\Q$, i.e., to find a set $\Q \ni 0$ such that 
$$
    \B + \Q \subset \A + \beta \Q\,.
$$  
We build $\Q$ iteratively so that we extend $\Q$ in a way to cover all elements on the left-hand side with original $\Q$ by elements on the right-hand side with extended $\Q$. This procedure is repeated until the extended weight coefficient set is the same as original one. 

In other words, we start with $\Q=\{0\}$ meaning that we search all weight coefficients $q_j$ necessary for conversion for the case where there is no carry from the right, i.e., $q_{j-1}=0$. We add them to weight coeffcient set $\Q$. These weight coefficients now may appear as a carry $q_{j-1}$. If there are no suitable weight coefficients $q_j$ in weight coefficient set $\Q$ to cover all sums of added coefficients and digits of input alphabet $\B$, we extend $\Q$ by appropriate ones. And so on until there is no need to add more elements. Here we mean by expression ``a weight coefficient $q$ covers an element $x$'' that there is $a \in \A$ such that $x=a + \beta q$.
    
The precise description of the semi-algorithm in a pseudocode in Algorithm \ref{alg:weightCoefSet}.  
    
\begin{algorithm}
  \caption{Search for weight coefficient set (Phase 1)}
    \label{alg:weightCoefSet}
  \begin{algorithmic}
    \STATE $k:=0$ 
    \STATE $Q_0:=\{0\}$
    \REPEAT
     \STATE  By Algorithm \ref{alg:extendWeightCoefSet}, extend $\Q_k$ to $\Q_{k+1}$ in a minimal possible way so that $$\B+ \Q_k \subset \A + \beta \Q_{k+1}$$
     \vspace{-20pt}
      \STATE  $k:=k+1$
      \UNTIL{$\Q_k = \Q_{k+1}$}      
      \STATE $\Q:=\Q_k$
    \RETURN $\Q$
  \end{algorithmic}
\end{algorithm}

To extend $\Q_{k}$ to $\Q_{k+1}$, we first find all possible candidates to cover each element of  $\B + \Q_{k}$ (Algorithm \ref{alg:searchCand}). 

\begin{algorithm}
  \caption{Search for candidates}
    \label{alg:searchCand}
  \begin{algorithmic}
    \REQUIRE{previous weight coefficient set $\Q_{k}$}
    \STATE \verb+candidates+:= empty list of lists
    \FORALL{$x \in \B + \Q_{k}$}
      \STATE \verb+cand_for_x+:= empty list
      \FORALL{$a \in \A$}
          \IF{$(x-a)$ is divisible by $\beta$ in $\Zomega$ NEBO ZBETA???}
              \STATE Append $\frac{x-a}{\beta}$ to \verb+cand_for_x+
            \ENDIF
      \ENDFOR 
      \STATE Append \verb+cand_for_x+ to \verb+candidates+
  \ENDFOR
  \RETURN \verb+candidates+
  \end{algorithmic}
\end{algorithm}  


An added element from each list of \verb+candidates+ is chosen as the smallest one unless there is already an covering element contained in $\Q_{k}$ (Algorithm \ref{alg:extendWeightCoefSet}).  

\begin{algorithm}
  \caption{Extending intermediate weight coefficient set}
    \label{alg:extendWeightCoefSet}
  \begin{algorithmic}
    \REQUIRE{\verb+candidates+ from Algorithm \ref{alg:searchCand}, previous weight coefficient set $\Q_{k}$}
    \STATE $\Q_{k+1}:=\Q_{k}$
    \FORALL{\texttt{cand\_for\_x} in \texttt{candidates}}
        \IF{no element of \texttt{cand\_for\_x} in $\Q_{k-1}$}
            \STATE Add the smallest element (in absolute value) of  \verb+cand_for_x+ to $\Q_{k}$  
        \ENDIF
    \ENDFOR
    \RETURN $\Q_{k+1}$
  \end{algorithmic}
\end{algorithm}
    
We may slightly improve this procedure: for example we may first extend $\Q_{k}$ by all single-element lists of \verb+candidates+. These elements may be enough to cover also other elements of $\B+\Q_{k}$. It implies that the resulting $\Q$ is dependent on the way of selection from \verb+candidates+.
  
    
    





\subsection{Phase 2 -- Weight function}
    We want to find a length of the window $M$ and a weight function $q:\B^{M} \to \Q$. The idea of the estending window method is to reduce necessary weight coefficients from weight coefficient set $\Q$ obtained in the previous section up to single value by enlarging number of considered input digits. The following notation is used: 
    \begin{defn}
        Let $\Q$ be a weight coefficient set and $w_j\in \B$. Denote by $\Q_{[w_j]}$ any set such that
        $$
            (\forall q_{j-1} \in \Q)(\exists q_j \in \Q_{[w_j]})(w_j + q_{j-1} - q_j \beta \in \A)\,.
        $$
        Inductively, for arbitrary $m \in \NN$ and for all $(w_{j},\dots, w_{j-m+1})\in \B^{m}$ denote by $\Q_{[w_{j},\dots, w_{j-m+1}]}$ any subset of  $\Q_{[w_{j},\dots, w_{j-m+2}]}$ such that 
        $$
           (\forall q_{j-1} \in \Q_{[w_{j-1},\dots, w_{j-m+1}]})(\exists q_j \in \Q_{[w_{j},\dots, w_{j-m+1}]})(w_j + q_{j-1} - q_j \beta \in \A)\,.
        $$
    \end{defn}
  
    Recall the scheme of conversion for better understanding of the definition and method:
    \begin{align*}
        \hspace{130pt}\cdots\; &w_{j+1}&\!\! &w_j  & \!\!  &w_{j-1}&\cdots w_{j-M+1} &w_{j-M}\cdots \hspace{130pt} \\[-3pt] 
                         & &       &q_{j-1}& -&\beta q_{j-1} \\[-3pt]
                           &q_j&   -&\beta q_j &&\\[-15pt]      
    \intertext{\hspace{120pt}\line(1,0){250}} 
          \vspace{-15pt}
          \\[-30pt]
     \cdots\; &z_{j+1}& &z_j& &z_{j-1}& \cdots z_{j-M+1}\; &z_{j-M}\cdots                     
    \end{align*}     
    The idea is to check all possible right carries $q_{j-1}\in\Q$ and determine values $q_j\in\Q$ such that 
    $$
    z_j=w_j + q_{j-1} - q_j \beta \in \A \,.
    $$  
    
    So we obtain a set $\Q_{[w_j]}\subset\Q$ of weight coefficients which are necessary to convert digit $w_j$ with any carry $q_{j-1}\in\Q$. Assuming that we know input digit $w_{j-1}$, the set of possible carries from the right is also reduced to $\Q_{[w_{j-1}]}$. Thus we may reduce the set $\Q_{[w_j]}$ to a set $\Q_{[w_j,w_{j-1}]}\subset \Q_{[w_j]}$ which is necessary to cover elements of $w_j + \Q_{[w_{j-1}]}$. Prolonging length of window in this manner may lead to a unique weight coefficient $q_j$ for enough given input digits.  
    
    Accordingly, the weight function $q$ is found if there is $M\in\NN$ such that 
    $$
    \#\Q_{[w_{j},\dots, w_{j-M+1}]}=1
    $$
    for all $w_{j},\dots, w_{j-M+1} \in \B^M$.
    
    The precise desription of the construction of the weight function is in  Algorithm \ref{alg:weightFunction}.
\begin{algorithm}
  \caption{Search for weight function (Phase 2)}
    \label{alg:weightFunction}
  \begin{algorithmic}
    \REQUIRE{weight coefficient set $\Q$}
    \STATE $m:=1$
    \FORALL{$w_j \in \B$} 
        \STATE Find minimal set $\Q_{[w_j]} \subset \Q$ such that
          $$
          w_j + \Q \subset \A + \beta \Q_{[w_j]}
          $$
    \ENDFOR
    \WHILE{$\max\{\#\Q_{[w_j,\dots, w_{j-m+1}]}:(w_j,\dots, w_{j-m+1}) \in \B^m \} > 1$}
        \STATE $m:= m +1$
        \FORALL{$(w_j,\dots, w_{j-m+1}) \in \B^{m}$}
            \STATE Find minimal set $\Q_{[w_j,\dots, w_{j-m+1}]} \subset \Q_{[w_j,\dots, w_{j-m+2}]}$ such that
              $$
              w_j + \Q_{[w_{j-1},\dots, w_{j-m+1}]} \subset \A + \beta \Q_{[w_j,\dots, w_{j-m+1}]}\,,
              $$
        \ENDFOR  
    \ENDWHILE  
    \STATE $M:= m$ 
    \FORALL{$(w_j,\dots, w_{j-M+1}) \in \B^{M}$}  
        \STATE $q(w_j,\dots, w_{j-M+1}):=$ only element of $\Q_{[w_j,\dots, w_{j-M+1}]}$
    \ENDFOR
    \RETURN $q$
  \end{algorithmic}
\end{algorithm}
    
For construction of minimal set $\Q_{[w_j,\dots, w_{j-m+1}]}$ we first choose elements which are the only ones covering some value in $x \in w_0 + \Q_{[w_{j-1},\dots, w_{j-m+1}]}$. Then we add to $\Q_{[w_j,\dots, w_{j-m+1}]}$ one by one elements from $\Q_{[w_j,\dots, w_{j-m+2}]}$ covering an uncovered value until each desired value equals $a+\beta q_j$ for some $q_j$ in $\Q_{[w_j,\dots, w_{j-m+1}]}$ and $a\in\A$. The pseudocode is in Algorithm \ref{alg:minimalSet}.

\begin{algorithm}
  \caption{Search for minimal set $\Q_{[w_j,\dots, w_{j-m+1}]}$ }
    \label{alg:minimalSet}
  \begin{algorithmic}[1]
    \REQUIRE{Input digit $w_j$, set of carries $\Q_{[w_{j-1},\dots, w_{j-m+1}]}$, previous set of possible weight coefficients $\Q_{[w_j,\dots, w_{j-m+2}]}$}
    \STATE \verb+list_of_coverings+:=empty list of lists
    \FORALL{$x \in w_0 + \Q_{[w_{j-1},\dots, w_{j-m+1}]}$}
        \STATE Build a list \verb+x_covered_by+ of weight coefficients $q_j \in \Q_{[w_j,\dots, w_{j-m+2}]}$ such that $x=a+ \beta q_j$ for some $a\in\A$
        \STATE Append  to \verb+list_of_coverings+
    \ENDFOR
    \STATE $\Q_{[w_j,\dots, w_{j-m+1}]}$:= empty set
%     \FORALL{\texttt{x\_covered\_by} in \texttt{list\_of\_coverings}}
%         \IF{\#\texttt{x\_covered\_by}=1}
%             \STATE Add the element of \verb+x_covered_by+ to $\Q_{[w_j,\dots, w_{j-m+1}]}$
%         \ENDIF
%     \ENDFOR
%     \STATE Remove lists \verb+x_covered_by+ containing any element of $\Q_{[w_j,\dots, w_{j-m+1}]}$ from \verb+list_of_coverings+
    \WHILE{\texttt{list\_of\_coverings} is nonempty}
        \STATE Pick any element $q$ of one of the shortest lists \verb+x_covered_by+
        \STATE Add the element $q$ to $\Q_{[w_j,\dots, w_{j-m+1}]}$
        \STATE Remove lists \verb+x_covered_by+ containing the element $q$ from \verb+list_of_coverings+
    \ENDWHILE
    \RETURN $\Q_{[w_j,\dots, w_{j-m+1}]}$
  \end{algorithmic}
\end{algorithm}

  
\section{Convergence}
Unfortunately, the extending window method is not always finite. The algorithm may lead to an infinite loop in both phases. 
However, the following lemmma gives a sufficient condition for convergence of the Phase 1. 
\begin{lem}
\label{lem:weightCoefSet}
    Let $\A$ and $\B$ be finite subsets of $\Zomega$ such that $\A$ contains at least one representative of each congruence class modulo $\beta$ in $\Zomega$. NEBO ZBeta???? Then, there exists a subset $\Q\subset\Zomega$ such that $ \B + \Q \subset \A + \beta \Q$ and all elements of $\Q$ are limited by constant $R\in \RR^+$ in modulus.
\end{lem}
\begin{proof}
 Denote $A:=\max\{|a|:a \in \A\}$ and $B:=\max\{|b|:b\in\B\}$. Consequently, set $R:=\frac{A+B}{|\beta|-1}$ and $\Q:=\{q\in\Zomega:|q|\leq R\}$. The set $\Q$ is nonempty because obviously $A>0$. Any element $x=b+q$ with $b\in\B$ and $q\in\Q$ can be written as $x=a+\beta q'$ for some $a\in\A$ due to existence of representative of each congruence class in $\A$. We prove that $|q'|\leq R$:
 $$
    |q'|=\frac{|b+q-a|}{|\beta|}\leq \frac{B+R+A}{|\beta|} \leq \frac{1}{|\beta|}\left(A+B+\frac{A+B}{|\beta|-1}\right)  =\frac{A+B}{|\beta|}\left(\frac{\beta}{|\beta|-1}\right)=R\,.
 $$ 
 Hence $q'\in\Q$ and thus  $x=b+q \in \A + \beta \Q$.
\end{proof}
We plug in the alphabet $\A$ and input alphabet $\B$. Because of the choice of smallest elements in Algorithm \ref{alg:extendWeightCoefSet}, we know by the lemma that the weight coefficient set $\Q$ constructed in Phase~1 has elements bounded by constant $R$. 
\begin{theo}
    Let $\omega$ be an algebraic integer such that any complex circle centered at 0 contains only finitely  many elements of $\Zomega$. Let $\beta \in \Zomega, |\beta|>1$. Let $\A$ and $\B$ be finite subsets of $\Zomega$ such that $\A$ contains at least one representative of each congruence class modulo $\beta$ in $\Zomega$. NEBO ZBeta???? Then, there exists a finite subset $\Q\subset\Zomega$ such that $ \B + \Q \subset \A + \beta \Q$.
\end{theo} 
\begin{proof}
    Directly from Lemma \ref{lem:weightCoefSet} and assumption on $\Zomega$.
\end{proof}
Therefore, Phase 1 succesfully ends if there can be only finitely many elements in $\Zomega$ NEBO Zbeta??? bounded by constant $R$ as intermediate weight coefficient sets $\Q_k$ have elements bounded by $R$ for all $k$. 
We categorize an algebraic integer $\omega$ which generates $\Zomega \ni \beta$ as follows:
\begin{itemize}
    \item $\omega \in \ZZ$ implies $\Zomega=\ZZ$ which has required property and thus Phase~1 converges.
    \item $\omega \in \RR\setminus\ZZ$ implies $\Zomega$ being dense in $\RR$. CITACE NEBO DUKAZ??? Thus the convergence of Phase~1 is not guaranteed and we have an example for which it does not converge.
    \item $\omega \in \CC\setminus\RR$, $\omega$ being quadratic algebraic integer implies that $\Zomega$ is not dense in $\CC$ and thus Phase~1 can converge. CO NEJAKY DUKAZ NEBO LEPSI ZDUVODNENI?????? NOT DENSE PORAD JESTE NEZNAMENA, ZE JICH NEMUZE BYT NEKONECNE...
    \item $\omega \in \CC\setminus\RR$, $\omega$ being algebraic integer of degree $\geq 3$ implies $\Zomega$ is  dense in $\CC$ and therefore the convergence of Phase~1 is not guaranteed.
\end{itemize}

We focus on Phase~2 now. For shorter notation, set 
$$
\Q^m_b:=\Q_{[\underbrace{b,\dots,b}_m]}
$$ for $m \in \NN$ and $b\in\B$.

Obviously, finitness of Phase~2 implies that there exists a length of window $M$ such that the set $\Q^M_b$ contains only one element for all $b\in\B$. 

\begin{algorithm}
  \caption{Check input $bb\dots b$}
    \label{alg:oneletterSets}
  \begin{algorithmic}[1]
    \REQUIRE{Weight coefficient set $\Q$, digit $b\in\B$}
    \STATE $m:=1$
    \STATE Find minimal set $\Q^1_b \subset \Q$ such that
      $$
      b + \Q \subset \A + \beta \Q^1_b\,.
      $$
      \vspace{-20pt}
    \WHILE{$\#\Q^m_b > 1$}
        \STATE $m:= m +1$
        \STATE By Algorithm \ref{alg:minimalSet}, find minimal set $\Q^m_b \subset \Q^{m-1}_b$ such that
          $$
          b + \Q^{m-1}_b \subset \A + \beta \Q^m_b\,.
          $$  
          \vspace{-20pt}
        \IF{$\#\Q^m_b=\#\Q^{m-1}_b$}
            \RETURN Phase 2 does not converge for input $bb\dots b$.
        \ENDIF
    \ENDWHILE  
    \RETURN Weight coefficient for input $bb\dots b$ is the only element of $\Q^m_b$.
  \end{algorithmic}
\end{algorithm}

For arbitrary $m$, sets $\Q^m_b$  can be easily constructed separately for each $b\in\B$. Using Lemma \ref{lem:stoppingCondition}, Algorithm \ref{alg:oneletterSets} checks whether Phase~2 stops processing input digits $bb\dots b$. Thus,  non-finitness of Phase~2 can be revealed by running it for each input digit $b\in\B$.
\begin{lem}
\label{lem:stoppingCondition}
Let $m_0 \in \NN$ be a length of window and $b\in\B$ be a letter of an input alphabet such that sets $\Q^{m_0}_b$ and $\Q^{{m_0}-1}_b$ produced by Algorithm \ref{alg:minimalSet} within Phase~2 have the same size. Then
$$
    \#\Q^m_b = \#\Q^{m_0}_b \qquad \forall m\geq m_0-1\,.
$$ 
Particulary, if $\#\Q^{m_0}_b\geq 2$, Phase~2 does not converge.
\end{lem}
\begin{proof}
It is enough to prove the base case of an induction as the inductive step is analogic. The set $\Q^{m_0+1}_b$ is find by Algorithm \ref{alg:minimalSet} such that 
$$
b + \Q^{m_0}_b \subset \A + \beta \Q^{m_0+1}_b\,
$$
and set $\Q^{m_0}_b$ was found by the same algorithm such that
$$
b + \Q^{m_0-1}_b \subset \A + \beta \Q^{m_0}_b\,.
$$
As $\Q^{m_0}_b \subset \Q^{{m_0}-1}_b$, the assumption of the same size implies
$$
    \Q^{m_0}_b = \Q^{{m_0}-1}_b\,.
$$
It means that Algorithm \ref{alg:minimalSet} runs with the same input and hence
$$
\Q^{m_0+1}_b=\Q^{m_0}_b\,.
$$
Phase 2 ends when there is only one element in $\Q_{[w_j,\dots, w_{j-m+1}]}$ for all $(w_j,\dots, w_{j-m+1}) \in \B^m$ for some fixed length of window $m$. But if $\#\Q^{m_0}_b\geq 2$, size of $\Q_{[b,\dots,b]}$ does not decrease despite of extending the length of window.
\end{proof}



  
\section{Complexity of the extending window method}


















